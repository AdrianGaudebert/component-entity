{"version":3,"file":"entity-manager.js","sources":["src/entity-manager.js"],"sourcesContent":["/*!\n * ensy - Entity System JavaScript Library v1.5.0\n *\n * A JavaScript implementation of the Entity System model as described by\n * Adam Martin in http://t-machine.org/index.php/2009/10/26/entity-systems-are-the-future-of-mmos-part-5/\n *\n * @author Adrian Gaudebert - adrian@gaudebert.fr\n * @license MIT license.\n * @documentation https://entity-system-js.readthedocs.io/\n *\n */\n\n/*!\n * Return a clone of an object.\n * From https://stackoverflow.com/questions/728360\n */\nfunction clone(obj) {\n    // Handle the 3 simple types, and null or undefined\n    if (null == obj || 'object' != typeof obj) return obj;\n\n    let copy;\n\n    // Handle Date\n    if (obj instanceof Date) {\n        copy = new Date();\n        copy.setTime(obj.getTime());\n        return copy;\n    }\n\n    // Handle Array\n    if (obj instanceof Array) {\n        copy = [];\n        for (let i = 0, len = obj.length; i < len; i++) {\n            copy[i] = clone(obj[i]);\n        }\n        return copy;\n    }\n\n    // Handle Object\n    if (obj instanceof Object) {\n        copy = {};\n        for (let attr in obj) {\n            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);\n        }\n        return copy;\n    }\n}\n\n/*!\n * Return true if the parameter is a function.\n * From https://stackoverflow.com/questions/5999998\n */\nfunction isFunction(thingToCheck) {\n    return thingToCheck && ({}).toString.call(thingToCheck) === '[object Function]';\n}\n\n/**\n * @class EntityManager\n *\n * Implement the Entity System model and provide tools to easily\n * create and manipulate Entities, Components and Processors.\n */\nclass EntityManager {\n    constructor(listener) {\n        this.listener = null;\n        if (listener && isFunction(listener.emit)) {\n            this.listener = listener;\n        }\n\n        // A list of entity IDs, each being a simple integer.\n        this.entities = [];\n\n        // A dictionary of components, where keys are the name of each\n        // component. Components are objects containing:\n        //  * metadata (name, description)\n        //  * the initial set of data that defines the default state of a\n        //    newly instanciated component\n        this.components = {};\n\n        // A dictionary of assemblages, where keys are the name of each\n        // assemblage. Assemblages are objects containing:\n        //  * metadata (name, description)\n        //  * a list of components to add to the entity\n        //  * an initial state for some components, to override the defaults\n        this.assemblages = {};\n\n        /*!\n         * A relational-like list of entity states. There is one line for\n         * each entity - component association.\n         *\n         * To optimize the access time to this data, it is stored in a\n         * dictionary of dictionaries of this form:\n         * {\n         *   \"componentId\": {\n         *     \"entityId\": {\n         *       ...\n         *       here comes the state of this entity for this component\n         *       ...\n         *     }\n         *   }\n         * }\n         *\n         * This way, getting the data of one entity for one component is:\n         *   this.entityComponentData[componentId][entityId]\n         * and getting all entities for one component is:\n         *   this.entityComponentData[componentId]\n         */\n        this.entityComponentData = {};\n\n        // The ordered list of processors known by this manager.\n        this.processors = [];\n\n        // The next unique identifier.\n        this.uid = 0;\n    }\n\n    /**\n     * Return an identifier unique to this system.\n     *\n     * @return {int} - Unique identifier.\n     */\n    getUid() {\n        return this.uid++;\n    }\n\n    //=========================================================================\n    // ENTITIES\n\n    /**\n     * Create a new entity in the system by creating a new instance of each of\n     * its components.\n     *\n     * @param {array} componentIds - List of identifiers of the components that compose the new entity.\n     * @param {int} entityId - Optional. Unique identifier of the entity. If passed, no new id will be generated.\n     * @return {int} - Unique identifier of the new entity.\n     */\n    createEntity(componentIds, entityId) {\n        if (typeof entityId === 'undefined' || entityId === null) {\n            entityId = this.getUid();\n        }\n        else if (entityId > this.uid) {\n            // Make sure another entity with the same ID won't be created in the future.\n            this.uid = entityId;\n        }\n\n        this.addComponentsToEntity(componentIds, entityId);\n        if (!this.entities.includes(entityId)) {\n            this.entities.push(entityId);\n        }\n        if (this.listener) {\n            // Signal the creation of a new entity.\n            this.listener.emit('entityCreated', entityId);\n        }\n        return entityId;\n    }\n\n    /**\n     * Remove an entity and its instanciated components from the system.\n     *\n     * @param {int} id - Unique identifier of the entity.\n     * @return {object} - this\n     */\n    removeEntity(id) {\n        // Remove all data for this entity.\n        for (let comp in this.entityComponentData) {\n            if (this.entityComponentData.hasOwnProperty(comp)) {\n                if (this.entityComponentData[comp][id]) {\n                    delete this.entityComponentData[comp][id];\n                }\n            }\n        }\n\n        // Remove the entity from the list of known entities.\n        this.entities.splice(this.entities.indexOf(id), 1);\n\n        if (this.listener) {\n            // Signal the removal of an entity.\n            this.listener.emit('entityRemoved', id);\n        }\n\n        return this;\n    }\n\n    //=========================================================================\n    // COMPONENTS\n\n    /**\n     * Add a component to the list of known components.\n     *\n     * @param {string} id - Unique identifier of the component.\n     * @param {object} component - Object containing the metadata and data of the component.\n     * @return {object} - this\n     */\n    addComponent(id, component) {\n        this.components[id] = component;\n        return this;\n    }\n\n    /**\n     * Add a list of components to known components.\n     *\n     * @param {Array} components - Array of objects containing the metadata and\n     * data of components. Requires that each object has `name` used to identify\n     * it, and `data` to describe it.\n     * @return {object} - this\n     */\n    addComponents(components) {\n        components.forEach(comp => this.addComponent(comp.name, comp));\n        return this;\n    }\n\n    /**\n     * Remove a component from the list of known components.\n     *\n     * @param {string} id - Unique identifier of the component.\n     * @return {object} - this\n     */\n    removeComponent(id) {\n        delete this.components[id];\n        delete this.entityComponentData[id];\n        return this;\n    }\n\n    /**\n     * Get the list of components this instance knows.\n     *\n     * @return {array} - List of names of components.\n     */\n    getComponentsList() {\n        return Object.keys(this.components);\n    }\n\n    /**\n     * Create a new instance of each listed component and associate them\n     * with the entity.\n     *\n     * @param {array} componentIds - List of identifiers of the components to add to the entity.\n     * @param {int} entityId - Unique identifier of the entity.\n     * @return {object} - this\n     */\n    addComponentsToEntity(componentIds, entityId) {\n        const self = this;\n\n        // First verify that all the components exist, and throw an error\n        // if any is unknown.\n        componentIds.forEach(comp => {\n            if (!this.components[comp]) {\n                throw new Error('Trying to use unknown component: ' + comp);\n            }\n        });\n\n        // Now we know that this request is correct, let's create the new\n        // entity and instanciate the component's states.\n        componentIds.forEach(comp => {\n            if (!this.entityComponentData[comp]) {\n                this.entityComponentData[comp] = {};\n            }\n\n            let newCompState = null;\n\n            // If the manager has a listener, we want to create getters\n            // and setters so that we can emit state changes. But if it does\n            // not have one, there is no need to add the overhead.\n            if (this.listener) {\n                newCompState = {};\n                (function (newCompState, comp) {\n                    let state = clone(self.components[comp].state);\n\n                    // Create a setter for each state attribute, so we can emit an\n                    // event whenever the state of this component changes.\n                    for (let property in state) {\n                        if (state.hasOwnProperty(property)) {\n                            (function (property) {\n                                Object.defineProperty(newCompState, property, {\n                                    enumerable: true,\n                                    get: function () {\n                                        return state[property];\n                                    },\n                                    set: function (val) {\n                                        state[property] = val;\n                                        self.listener.emit('entityComponentUpdated', entityId, comp);\n                                    },\n                                });\n                            })(property);\n                        }\n                    }\n                })(newCompState, comp);\n            }\n            else {\n                newCompState = clone(self.components[comp].state);\n            }\n\n            // Store the entity's ID so it's easier to find other components for that entity.\n            newCompState.__id = entityId;\n\n            this.entityComponentData[comp][entityId] = newCompState;\n\n            if (this.listener) {\n                // Signal the addition of a new component to the entity.\n                this.listener.emit('entityComponentAdded', entityId, comp);\n            }\n        });\n\n        componentIds.forEach(componentId => {\n            this.sendEventToProcessors('COMPONENT_CREATED', entityId, componentId);\n        });\n\n        return this;\n    }\n\n    /**\n     * De-associate a list of components from the entity.\n     *\n     * @param {array} componentIds - List of identifiers of the components to remove from the entity.\n     * @param {int} entityId - Unique identifier of the entity.\n     * @return {object} - this\n     */\n    removeComponentsFromEntity(componentIds, entityId) {\n        // First verify that all the components exist, and throw an error\n        // if any is unknown.\n        componentIds.forEach(comp => {\n            if (!this.components[comp]) {\n                throw new Error('Trying to use unknown component: ' + comp);\n            }\n        });\n\n        // Now we know that this request is correct, let's remove all the\n        // components' states for that entity.\n        componentIds.forEach(comp => {\n            if (this.entityComponentData[comp]) {\n                if (this.entityComponentData[comp][entityId]) {\n                    delete this.entityComponentData[comp][entityId];\n                    if (this.listener) {\n                        // Signal the creation of a new entity.\n                        this.listener.emit('entityComponentRemoved', entityId, comp);\n                    }\n                }\n            }\n        });\n\n\n        return this;\n    }\n\n    /**\n     * Return a reference to an object that contains the data of an\n     * instanciated component of an entity.\n     *\n     * @param {int} entityId - Unique identifier of the entity.\n     * @param {string} componentId - Unique identifier of the component.\n     * @return {object} - Component data of one entity.\n     */\n    getComponentDataForEntity(componentId, entityId) {\n        if (!(componentId in this.components)) {\n            throw new Error('Trying to use unknown component: ' + componentId);\n        }\n\n        if (\n            !this.entityComponentData.hasOwnProperty(componentId) ||\n            !this.entityComponentData[componentId].hasOwnProperty(entityId)\n        ) {\n            throw new Error('No data for component ' + componentId + ' and entity ' + entityId);\n        }\n\n        return this.entityComponentData[componentId][entityId];\n    }\n\n    /**\n     * Update the state of a component, many keys at once.\n     *\n     * @param {int} entityId - Unique identifier of the entity.\n     * @param {string} componentId - Unique identifier of the component.\n     * @param {object} newState - Object containing the new state to apply.\n     * @return {object} - this\n     */\n    updateComponentDataForEntity(componentId, entityId, newState) {\n        const compState = this.getComponentDataForEntity(componentId, entityId);\n\n        for (let key in newState) {\n            if (newState.hasOwnProperty(key) && compState.hasOwnProperty(key)) {\n                compState[key] = newState[key];\n            }\n        }\n\n        this.sendEventToProcessors('COMPONENT_UPDATED', entityId, componentId);\n\n        return this;\n    }\n\n    /**\n     * Return a dictionary of objects containing the data of all instances of a\n     * given component.\n     *\n     * @param {string} componentId - Unique identifier of the component.\n     * @return {Object} - Dictionary of entity id -> component data.\n     */\n    getComponentsData(componentId) {\n        if (!(componentId in this.components)) {\n            throw new Error('Trying to use unknown component: ' + componentId);\n        }\n\n        if (!this.entityComponentData.hasOwnProperty(componentId)) {\n            return {};\n        }\n\n        return this.entityComponentData[componentId];\n    }\n\n    /**\n     * Return true if the entity has the component.\n     *\n     * @param {int} entityId - Unique identifier of the entity.\n     * @param {string} componentId - Unique identifier of the component.\n     * @return {boolean} - True if the entity has the component.\n     */\n    entityHasComponent(entityId, componentId) {\n        if (!(componentId in this.components)) {\n            return false;\n        }\n\n        return (\n            this.entityComponentData.hasOwnProperty(componentId) &&\n            this.entityComponentData[componentId].hasOwnProperty(entityId)\n        );\n    }\n\n    //=========================================================================\n    // ASSEMBLAGES\n\n    /**\n     * Add an assemblage to the list of known assemblages.\n     *\n     * @param {string} id - Unique identifier of the assemblage.\n     * @param {object} assemblage - An instance of an assemblage to add.\n     * @return {object} - this\n     */\n    addAssemblage(id, assemblage) {\n        this.assemblages[id] = assemblage;\n        return this;\n    }\n\n    /**\n     * Add a list of assemblages to known assemblages.\n     *\n     * @param {Array} assemblages - An array of assemblages to add. Require that\n     * each object has a `name` property to use as identifier.\n     * @return {object} - this\n     */\n    addAssemblages(assemblages) {\n        assemblages.forEach(a => this.assemblages[a.name] = a);\n        return this;\n    }\n\n    /**\n     * Remove an assemblage from the list of known assemblages.\n     *\n     * @param {string} id - Unique identifier of the assemblage.\n     * @return {object} - this\n     */\n    removeAssemblage(id) {\n        delete this.assemblages[id];\n        return this;\n    }\n\n    /**\n     * Create a new entity in the system by creating a new instance of each of\n     * its components and setting their initial state, using an assemblage.\n     *\n     * @param {string} assemblageId - Id of the assemblage to create the entity from.\n     * @return {int} - Unique identifier of the new entity.\n     */\n    createEntityFromAssemblage(assemblageId) {\n        if (!(assemblageId in this.assemblages)) {\n            throw new Error('Trying to use unknown assemblage: ' + assemblageId);\n        }\n\n        const assemblage = this.assemblages[assemblageId];\n        const entity = this.createEntity(assemblage.components);\n\n        for (let comp in assemblage.initialState) {\n            if (assemblage.initialState.hasOwnProperty(comp)) {\n                const newState = assemblage.initialState[comp];\n                this.updateComponentDataForEntity(comp, entity, newState);\n            }\n        }\n\n        return entity;\n    }\n\n    //=========================================================================\n    // PROCESSORS\n\n    /**\n     * Add a processor to the list of known processors.\n     *\n     * @param {object} processor - An instance of a processor to manage.\n     * @return {object} - this\n     */\n    addProcessor(processor) {\n        this.processors.push(processor);\n        return this;\n    }\n\n    /**\n     * Add a list of processors to known processors.\n     *\n     * @param {Array} processors - An array of processors to manage.\n     * @return {object} - this\n     */\n    addProcessors(processors) {\n        processors.forEach(processor => this.processors.push(processor));\n        return this;\n    }\n\n    /**\n     * Remove a processor from the list of known processors.\n     *\n     * @param {object} processor - An instance of a processor to remove.\n     * @return {object} - this\n     */\n    removeProcessor(processor) {\n        this.processors.splice(this.processors.indexOf(processor), 1);\n        return this;\n    }\n\n    /**\n     * Send an event to the list of known processors.\n     *\n     * @param {string} eventName - Id of the event to send.\n     * @param {number} entityId - Unique identifier of the entity on which the event occured.\n     * @param {string} componentId - Unique identifier of the component on which the event occured.\n     * @return {object} - this\n     */\n    sendEventToProcessors(eventName, entityId, componentId) {\n        this.processors.forEach(processor => {\n            if ('on' in processor && typeof processor.on === 'function') {\n                processor.on(eventName, {\n                    entity: entityId,\n                    component: componentId,\n                    state: this.entityComponentData[componentId][entityId]\n                });\n            }\n        });\n    }\n\n    /**\n     * Update all the known processors.\n     *\n     * @param {int} dt - The time delta since the last call to update. Will be passed as an argument to all processor's `update` method.\n     * @return {object} - this\n     */\n    update(dt) {\n        this.processors.forEach(processor => processor.update(dt));\n        return this;\n    }\n}\n\nexport default EntityManager;\n"],"names":["clone","obj","copy","Date","setTime","getTime","Array","i","len","length","Object","attr","hasOwnProperty","listener","thingToCheck","emit","toString","call","entities","components","assemblages","entityComponentData","processors","uid","this","componentIds","entityId","getUid","addComponentsToEntity","includes","push","id","comp","splice","indexOf","component","forEach","_this","addComponent","name","keys","self","_this2","Error","newCompState","state","property","defineProperty","enumerable","get","set","val","__id","componentId","sendEventToProcessors","_this3","newState","compState","getComponentDataForEntity","key","assemblage","a","_this4","assemblageId","entity","createEntity","initialState","updateComponentDataForEntity","processor","_this5","eventName","on","_this6","dt","update"],"mappings":";;;;;;;;;;;;;;;;AAgBA,SAASA,EAAMC,MAEP,MAAQA,GAAO,YAAmBA,GAAK,OAAOA,MAE9CC,KAGAD,aAAeE,YACfD,EAAO,IAAIC,MACNC,QAAQH,EAAII,WACVH,KAIPD,aAAeK,MAAO,CACtBJ,EAAO,OACF,IAAIK,EAAI,EAAGC,EAAMP,EAAIQ,OAAQF,EAAIC,EAAKD,IACvCL,EAAKK,GAAKP,EAAMC,EAAIM,WAEjBL,KAIPD,aAAeS,OAAQ,KAElB,IAAIC,KADTT,EAAO,GACUD,EACTA,EAAIW,eAAeD,KAAOT,EAAKS,GAAQX,EAAMC,EAAIU,YAElDT;;;;kCAmBCW,GAXhB,IAAoBC,6GAYPD,SAAW,KACZA,KAbQC,EAaeD,EAASE,OAZoB,sBAApC,GAAIC,SAASC,KAAKH,WAa7BD,SAAWA,QAIfK,SAAW,QAOXC,WAAa,QAObC,YAAc;;;;;;;;;;;;;;;;;;;;;;KAuBdC,oBAAsB,QAGtBC,WAAa,QAGbC,IAAM,iEASJC,KAAKD,2CAcHE,EAAcC,UACnB,MAAOA,EACPA,EAAWF,KAAKG,SAEXD,EAAWF,KAAKD,WAEhBA,IAAMG,QAGVE,sBAAsBH,EAAcC,GACpCF,KAAKN,SAASW,SAASH,SACnBR,SAASY,KAAKJ,GAEnBF,KAAKX,eAEAA,SAASE,KAAK,gBAAiBW,GAEjCA,uCASEK,OAEJ,IAAIC,KAAQR,KAAKH,oBACdG,KAAKH,oBAAoBT,eAAeoB,IACpCR,KAAKH,oBAAoBW,GAAMD,WACxBP,KAAKH,oBAAoBW,GAAMD,eAM7Cb,SAASe,OAAOT,KAAKN,SAASgB,QAAQH,GAAK,GAE5CP,KAAKX,eAEAA,SAASE,KAAK,gBAAiBgB,GAGjCP,0CAaEO,EAAII,eACRhB,WAAWY,GAAMI,EACfX,2CAWGL,qBACVA,EAAWiB,SAAQ,SAAAJ,UAAQK,EAAKC,aAAaN,EAAKO,KAAMP,MACjDR,6CASKO,iBACLP,KAAKL,WAAWY,UAChBP,KAAKH,oBAAoBU,GACzBP,wDASAd,OAAO8B,KAAKhB,KAAKL,0DAWNM,EAAcC,cAC1Be,EAAOjB,YAIbC,EAAaW,SAAQ,SAAAJ,OACZU,EAAKvB,WAAWa,SACX,IAAIW,MAAM,oCAAsCX,MAM9DP,EAAaW,SAAQ,SAAAJ,GACZU,EAAKrB,oBAAoBW,KAC1BU,EAAKrB,oBAAoBW,GAAQ,QAGjCY,EAAe,KAKfF,EAAK7B,kBAEM+B,EAAcZ,OACjBa,EAAQ7C,EAAMyC,EAAKtB,WAAWa,GAAMa,WAInC,IAAIC,KAAYD,EACbA,EAAMjC,eAAekC,aACVA,GACPpC,OAAOqC,eAAeH,EAAcE,EAAU,CAC1CE,YAAY,EACZC,IAAK,kBACMJ,EAAMC,IAEjBI,IAAK,SAAUC,GACXN,EAAMC,GAAYK,EAClBV,EAAK5B,SAASE,KAAK,yBAA0BW,EAAUM,OAGhEc,IAnBfF,EAAe,GAsBEZ,GAGjBY,EAAe5C,EAAMyC,EAAKtB,WAAWa,GAAMa,OAI/CD,EAAaQ,KAAO1B,EAEpBgB,EAAKrB,oBAAoBW,GAAMN,GAAYkB,EAEvCF,EAAK7B,UAEL6B,EAAK7B,SAASE,KAAK,uBAAwBW,EAAUM,MAI7DP,EAAaW,SAAQ,SAAAiB,GACjBX,EAAKY,sBAAsB,oBAAqB5B,EAAU2B,MAGvD7B,wDAUgBC,EAAcC,qBAGrCD,EAAaW,SAAQ,SAAAJ,OACZuB,EAAKpC,WAAWa,SACX,IAAIW,MAAM,oCAAsCX,MAM9DP,EAAaW,SAAQ,SAAAJ,GACbuB,EAAKlC,oBAAoBW,IACrBuB,EAAKlC,oBAAoBW,GAAMN,YACxB6B,EAAKlC,oBAAoBW,GAAMN,GAClC6B,EAAK1C,UAEL0C,EAAK1C,SAASE,KAAK,yBAA0BW,EAAUM,OAOhER,uDAWe6B,EAAa3B,QAC7B2B,KAAe7B,KAAKL,kBAChB,IAAIwB,MAAM,oCAAsCU,OAIrD7B,KAAKH,oBAAoBT,eAAeyC,KACxC7B,KAAKH,oBAAoBgC,GAAazC,eAAec,SAEhD,IAAIiB,MAAM,yBAA2BU,EAAc,eAAiB3B,UAGvEF,KAAKH,oBAAoBgC,GAAa3B,wDAWpB2B,EAAa3B,EAAU8B,OAC1CC,EAAYjC,KAAKkC,0BAA0BL,EAAa3B,OAEzD,IAAIiC,KAAOH,EACRA,EAAS5C,eAAe+C,IAAQF,EAAU7C,eAAe+C,KACzDF,EAAUE,GAAOH,EAASG,gBAI7BL,sBAAsB,oBAAqB5B,EAAU2B,GAEnD7B,+CAUO6B,QACRA,KAAe7B,KAAKL,kBAChB,IAAIwB,MAAM,oCAAsCU,UAGrD7B,KAAKH,oBAAoBT,eAAeyC,GAItC7B,KAAKH,oBAAoBgC,GAHrB,8CAaI3B,EAAU2B,UACnBA,KAAe7B,KAAKL,YAKtBK,KAAKH,oBAAoBT,eAAeyC,IACxC7B,KAAKH,oBAAoBgC,GAAazC,eAAec,yCAc/CK,EAAI6B,eACTxC,YAAYW,GAAM6B,EAChBpC,4CAUIJ,qBACXA,EAAYgB,SAAQ,SAAAyB,UAAKC,EAAK1C,YAAYyC,EAAEtB,MAAQsB,KAC7CrC,8CASMO,iBACNP,KAAKJ,YAAYW,GACjBP,wDAUgBuC,QACjBA,KAAgBvC,KAAKJ,mBACjB,IAAIuB,MAAM,qCAAuCoB,OAGrDH,EAAapC,KAAKJ,YAAY2C,GAC9BC,EAASxC,KAAKyC,aAAaL,EAAWzC,gBAEvC,IAAIa,KAAQ4B,EAAWM,gBACpBN,EAAWM,aAAatD,eAAeoB,GAAO,KACxCwB,EAAWI,EAAWM,aAAalC,QACpCmC,6BAA6BnC,EAAMgC,EAAQR,UAIjDQ,uCAYEI,eACJ9C,WAAWQ,KAAKsC,GACd5C,2CASGF,qBACVA,EAAWc,SAAQ,SAAAgC,UAAaC,EAAK/C,WAAWQ,KAAKsC,MAC9C5C,6CASK4C,eACP9C,WAAWW,OAAOT,KAAKF,WAAWY,QAAQkC,GAAY,GACpD5C,mDAWW8C,EAAW5C,EAAU2B,mBAClC/B,WAAWc,SAAQ,SAAAgC,GAChB,OAAQA,GAAqC,mBAAjBA,EAAUG,IACtCH,EAAUG,GAAGD,EAAW,CACpBN,OAAQtC,EACRS,UAAWkB,EACXR,MAAO2B,EAAKnD,oBAAoBgC,GAAa3B,uCAYtD+C,eACEnD,WAAWc,SAAQ,SAAAgC,UAAaA,EAAUM,OAAOD,MAC/CjD"}