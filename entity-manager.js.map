{"version":3,"file":"entity-manager.js","sources":["src/entity-manager.js"],"sourcesContent":["/*!\n * ensy - Entity System JavaScript Library v1.5.0\n *\n * A JavaScript implementation of the Entity System model as described by\n * Adam Martin in http://t-machine.org/index.php/2009/10/26/entity-systems-are-the-future-of-mmos-part-5/\n *\n * @author Adrian Gaudebert - adrian@gaudebert.fr\n * @license MIT license.\n * @documentation https://entity-system-js.readthedocs.io/\n *\n */\n\n/*!\n * Return a clone of an object.\n * From https://stackoverflow.com/questions/728360\n */\nfunction clone(obj) {\n    // Handle the 3 simple types, and null or undefined\n    if (null == obj || 'object' != typeof obj) return obj;\n\n    let copy;\n\n    // Handle Date\n    if (obj instanceof Date) {\n        copy = new Date();\n        copy.setTime(obj.getTime());\n        return copy;\n    }\n\n    // Handle Array\n    if (obj instanceof Array) {\n        copy = [];\n        for (let i = 0, len = obj.length; i < len; i++) {\n            copy[i] = clone(obj[i]);\n        }\n        return copy;\n    }\n\n    // Handle Object\n    if (obj instanceof Object) {\n        copy = {};\n        for (let attr in obj) {\n            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);\n        }\n        return copy;\n    }\n}\n\n/*!\n * Return true if the parameter is a function.\n * From https://stackoverflow.com/questions/5999998\n */\nfunction isFunction(thingToCheck) {\n    return thingToCheck && ({}).toString.call(thingToCheck) === '[object Function]';\n}\n\n/**\n * @class EntityManager\n *\n * Implement the Entity System model and provide tools to easily\n * create and manipulate Entities, Components and Processors.\n */\nclass EntityManager {\n    constructor(listener) {\n        this.listener = null;\n        if (listener && isFunction(listener.emit)) {\n            this.listener = listener;\n        }\n\n        // A list of entity IDs, each being a simple integer.\n        this.entities = [];\n\n        // A dictionary of components, where keys are the name of each\n        // component. Components are objects containing:\n        //  * metadata (name, description)\n        //  * the initial set of data that defines the default state of a\n        //    newly instanciated component\n        this.components = {};\n\n        // A dictionary of assemblages, where keys are the name of each\n        // assemblage. Assemblages are objects containing:\n        //  * metadata (name, description)\n        //  * a list of components to add to the entity\n        //  * an initial state for some components, to override the defaults\n        this.assemblages = {};\n\n        /*!\n         * A relational-like list of entity states. There is one line for\n         * each entity - component association.\n         *\n         * To optimize the access time to this data, it is stored in a\n         * dictionary of dictionaries of this form:\n         * {\n         *   \"componentId\": {\n         *     \"entityId\": {\n         *       ...\n         *       here comes the state of this entity for this component\n         *       ...\n         *     }\n         *   }\n         * }\n         *\n         * This way, getting the data of one entity for one component is:\n         *   this.entityComponentData[componentId][entityId]\n         * and getting all entities for one component is:\n         *   this.entityComponentData[componentId]\n         */\n        this.entityComponentData = {};\n\n        // The ordered list of processors known by this manager.\n        this.processors = [];\n\n        // The next unique identifier.\n        this.uid = 0;\n    }\n\n    /**\n     * Return an identifier unique to this system.\n     *\n     * @return {int} - Unique identifier.\n     */\n    getUid() {\n        return this.uid++;\n    }\n\n    //=========================================================================\n    // ENTITIES\n\n    /**\n     * Create a new entity in the system by creating a new instance of each of its components.\n     *\n     * @param {array} componentIds - List of identifiers of the components that compose the new entity.\n     * @param {int} entityId - Optional. Unique identifier of the entity. If passed, no new id will be generated.\n     * @param {object} initialState - Optional. Object containing the initial state to apply.\n     * @return {int} - Unique identifier of the new entity.\n     */\n    createEntity(componentIds, entityId, initialState) {\n        if (typeof entityId === 'undefined' || entityId === null) {\n            entityId = this.getUid();\n        }\n        else if (entityId > this.uid) {\n            // Make sure another entity with the same ID won't be created in the future.\n            this.uid = entityId;\n        }\n\n        this.addComponentsToEntity(componentIds, entityId, initialState);\n        if (!this.entities.includes(entityId)) {\n            this.entities.push(entityId);\n        }\n        if (this.listener) {\n            // Signal the creation of a new entity.\n            this.listener.emit('entityCreated', entityId);\n        }\n        return entityId;\n    }\n\n    /**\n     * Remove an entity and its instanciated components from the system.\n     *\n     * @param {int} id - Unique identifier of the entity.\n     * @return {object} - this\n     */\n    removeEntity(id) {\n        // Remove all data for this entity.\n        for (let comp in this.entityComponentData) {\n            if (this.entityComponentData.hasOwnProperty(comp)) {\n                if (this.entityComponentData[comp][id]) {\n                    delete this.entityComponentData[comp][id];\n                }\n            }\n        }\n\n        // Remove the entity from the list of known entities.\n        this.entities.splice(this.entities.indexOf(id), 1);\n\n        if (this.listener) {\n            // Signal the removal of an entity.\n            this.listener.emit('entityRemoved', id);\n        }\n\n        return this;\n    }\n\n    //=========================================================================\n    // COMPONENTS\n\n    /**\n     * Add a component to the list of known components.\n     *\n     * @param {string} id - Unique identifier of the component.\n     * @param {object} component - Object containing the metadata and data of the component.\n     * @return {object} - this\n     */\n    addComponent(id, component) {\n        this.components[id] = component;\n        return this;\n    }\n\n    /**\n     * Add a list of components to known components.\n     *\n     * @param {Array} components - Array of objects containing the metadata and\n     * data of components. Requires that each object has `name` used to identify\n     * it, and `data` to describe it.\n     * @return {object} - this\n     */\n    addComponents(components) {\n        components.forEach(comp => this.addComponent(comp.name, comp));\n        return this;\n    }\n\n    /**\n     * Remove a component from the list of known components.\n     *\n     * @param {string} id - Unique identifier of the component.\n     * @return {object} - this\n     */\n    removeComponent(id) {\n        delete this.components[id];\n        delete this.entityComponentData[id];\n        return this;\n    }\n\n    /**\n     * Get the list of components this instance knows.\n     *\n     * @return {array} - List of names of components.\n     */\n    getComponentsList() {\n        return Object.keys(this.components);\n    }\n\n    /**\n     * Create a new instance of each listed component and associate them with the entity.\n     *\n     * @param {array} componentIds - List of identifiers of the components to add to the entity.\n     * @param {int} entityId - Unique identifier of the entity.\n     * @param {object} initialState - Optional. Object containing the initial state to apply.\n     * @return {object} - this\n     */\n    addComponentsToEntity(componentIds, entityId, initialState) {\n        const self = this;\n\n        // First verify that all the components exist, and throw an error\n        // if any is unknown.\n        componentIds.forEach(comp => {\n            if (!this.components[comp]) {\n                throw new Error('Trying to use unknown component: ' + comp);\n            }\n        });\n\n        // Now we know that this request is correct, let's create the new\n        // entity and instanciate the component's states.\n        componentIds.forEach(comp => {\n            if (!this.entityComponentData[comp]) {\n                this.entityComponentData[comp] = {};\n            }\n\n            let newCompState = null;\n\n            // If the manager has a listener, we want to create getters\n            // and setters so that we can emit state changes. But if it does\n            // not have one, there is no need to add the overhead.\n            if (this.listener) {\n                newCompState = {};\n                (function (newCompState, comp) {\n                    let state = clone(self.components[comp].state);\n\n                    // Create a setter for each state attribute, so we can emit an\n                    // event whenever the state of this component changes.\n                    for (let property in state) {\n                        if (state.hasOwnProperty(property)) {\n                            (function (property) {\n                                Object.defineProperty(newCompState, property, {\n                                    enumerable: true,\n                                    get: function () {\n                                        return state[property];\n                                    },\n                                    set: function (val) {\n                                        state[property] = val;\n                                        self.listener.emit('entityComponentUpdated', entityId, comp);\n                                    },\n                                });\n                            })(property);\n                        }\n                    }\n                })(newCompState, comp);\n            }\n            else {\n                newCompState = clone(self.components[comp].state);\n            }\n\n            // Store the entity's ID so it's easier to find other components for that entity.\n            newCompState.__id = entityId;\n\n            this.entityComponentData[comp][entityId] = newCompState;\n\n            if (this.listener) {\n                // Signal the addition of a new component to the entity.\n                this.listener.emit('entityComponentAdded', entityId, comp);\n            }\n        });\n\n        if (initialState) {\n            for (let componentId in initialState) {\n                if (initialState.hasOwnProperty(componentId)) {\n                    const newState = initialState[componentId];\n                    this.updateComponentDataForEntity(componentId, entityId, newState, false);\n                }\n            }\n        }\n\n        componentIds.forEach(componentId => {\n            this.sendEventToProcessors('COMPONENT_CREATED', entityId, componentId);\n        });\n\n        return this;\n    }\n\n    /**\n     * De-associate a list of components from the entity.\n     *\n     * @param {array} componentIds - List of identifiers of the components to remove from the entity.\n     * @param {int} entityId - Unique identifier of the entity.\n     * @return {object} - this\n     */\n    removeComponentsFromEntity(componentIds, entityId) {\n        // First verify that all the components exist, and throw an error\n        // if any is unknown.\n        componentIds.forEach(comp => {\n            if (!this.components[comp]) {\n                throw new Error('Trying to use unknown component: ' + comp);\n            }\n        });\n\n        // Now we know that this request is correct, let's remove all the\n        // components' states for that entity.\n        componentIds.forEach(comp => {\n            if (this.entityComponentData[comp]) {\n                if (this.entityComponentData[comp][entityId]) {\n                    delete this.entityComponentData[comp][entityId];\n                    if (this.listener) {\n                        // Signal the creation of a new entity.\n                        this.listener.emit('entityComponentRemoved', entityId, comp);\n                    }\n                }\n            }\n        });\n\n\n        return this;\n    }\n\n    /**\n     * Return a reference to an object that contains the data of an\n     * instanciated component of an entity.\n     *\n     * @param {int} entityId - Unique identifier of the entity.\n     * @param {string} componentId - Unique identifier of the component.\n     * @return {object} - Component data of one entity.\n     */\n    getComponentDataForEntity(componentId, entityId) {\n        if (!(componentId in this.components)) {\n            throw new Error('Trying to use unknown component: ' + componentId);\n        }\n\n        if (\n            !this.entityComponentData.hasOwnProperty(componentId) ||\n            !this.entityComponentData[componentId].hasOwnProperty(entityId)\n        ) {\n            throw new Error('No data for component ' + componentId + ' and entity ' + entityId);\n        }\n\n        return this.entityComponentData[componentId][entityId];\n    }\n\n    /**\n     * Update the state of a component, many keys at once.\n     *\n     * @param {int} entityId - Unique identifier of the entity.\n     * @param {string} componentId - Unique identifier of the component.\n     * @param {object} newState - Object containing the new state to apply.\n     * @param {boolean} sendUpdateEvent - Optional. True if the method has to send the `COMPONENT_UPDATED` event.\n     * @return {object} - this\n     */\n    updateComponentDataForEntity(componentId, entityId, newState, sendUpdateEvent = true) {\n        const compState = this.getComponentDataForEntity(componentId, entityId);\n\n        for (let key in newState) {\n            if (newState.hasOwnProperty(key) && compState.hasOwnProperty(key)) {\n                compState[key] = newState[key];\n            }\n        }\n\n        if (sendUpdateEvent) {\n            this.sendEventToProcessors('COMPONENT_UPDATED', entityId, componentId);\n        }\n\n        return this;\n    }\n\n    /**\n     * Return a dictionary of objects containing the data of all instances of a\n     * given component.\n     *\n     * @param {string} componentId - Unique identifier of the component.\n     * @return {Object} - Dictionary of entity id -> component data.\n     */\n    getComponentsData(componentId) {\n        if (!(componentId in this.components)) {\n            throw new Error('Trying to use unknown component: ' + componentId);\n        }\n\n        if (!this.entityComponentData.hasOwnProperty(componentId)) {\n            return {};\n        }\n\n        return this.entityComponentData[componentId];\n    }\n\n    /**\n     * Return true if the entity has the component.\n     *\n     * @param {int} entityId - Unique identifier of the entity.\n     * @param {string} componentId - Unique identifier of the component.\n     * @return {boolean} - True if the entity has the component.\n     */\n    entityHasComponent(entityId, componentId) {\n        if (!(componentId in this.components)) {\n            return false;\n        }\n\n        return (\n            this.entityComponentData.hasOwnProperty(componentId) &&\n            this.entityComponentData[componentId].hasOwnProperty(entityId)\n        );\n    }\n\n    //=========================================================================\n    // ASSEMBLAGES\n\n    /**\n     * Add an assemblage to the list of known assemblages.\n     *\n     * @param {string} id - Unique identifier of the assemblage.\n     * @param {object} assemblage - An instance of an assemblage to add.\n     * @return {object} - this\n     */\n    addAssemblage(id, assemblage) {\n        this.assemblages[id] = assemblage;\n        return this;\n    }\n\n    /**\n     * Add a list of assemblages to known assemblages.\n     *\n     * @param {Array} assemblages - An array of assemblages to add. Require that\n     * each object has a `name` property to use as identifier.\n     * @return {object} - this\n     */\n    addAssemblages(assemblages) {\n        assemblages.forEach(a => this.assemblages[a.name] = a);\n        return this;\n    }\n\n    /**\n     * Remove an assemblage from the list of known assemblages.\n     *\n     * @param {string} id - Unique identifier of the assemblage.\n     * @return {object} - this\n     */\n    removeAssemblage(id) {\n        delete this.assemblages[id];\n        return this;\n    }\n\n    /**\n     * Create a new entity in the system by creating a new instance of each of\n     * its components and setting their initial state, using an assemblage.\n     *\n     * @param {string} assemblageId - Id of the assemblage to create the entity from.\n     * @return {int} - Unique identifier of the new entity.\n     */\n    createEntityFromAssemblage(assemblageId) {\n        if (!(assemblageId in this.assemblages)) {\n            throw new Error('Trying to use unknown assemblage: ' + assemblageId);\n        }\n\n        const assemblage = this.assemblages[assemblageId];\n        const entity = this.createEntity(assemblage.components, undefined, assemblage.initialState);\n\n        return entity;\n    }\n\n    //=========================================================================\n    // PROCESSORS\n\n    /**\n     * Add a processor to the list of known processors.\n     *\n     * @param {object} processor - An instance of a processor to manage.\n     * @return {object} - this\n     */\n    addProcessor(processor) {\n        this.processors.push(processor);\n        return this;\n    }\n\n    /**\n     * Add a list of processors to known processors.\n     *\n     * @param {Array} processors - An array of processors to manage.\n     * @return {object} - this\n     */\n    addProcessors(processors) {\n        processors.forEach(processor => this.processors.push(processor));\n        return this;\n    }\n\n    /**\n     * Remove a processor from the list of known processors.\n     *\n     * @param {object} processor - An instance of a processor to remove.\n     * @return {object} - this\n     */\n    removeProcessor(processor) {\n        this.processors.splice(this.processors.indexOf(processor), 1);\n        return this;\n    }\n\n    /**\n     * Send an event to the list of known processors.\n     *\n     * @param {string} eventName - Id of the event to send.\n     * @param {number} entityId - Unique identifier of the entity on which the event occured.\n     * @param {string} componentId - Unique identifier of the component on which the event occured.\n     * @return {object} - this\n     */\n    sendEventToProcessors(eventName, entityId, componentId) {\n        this.processors.forEach(processor => {\n            if ('on' in processor && typeof processor.on === 'function') {\n                processor.on(eventName, {\n                    entity: entityId,\n                    component: componentId,\n                    state: this.entityComponentData[componentId][entityId]\n                });\n            }\n        });\n    }\n\n    /**\n     * Update all the known processors.\n     *\n     * @param {int} dt - The time delta since the last call to update. Will be passed as an argument to all processor's `update` method.\n     * @return {object} - this\n     */\n    update(dt) {\n        this.processors.forEach(processor => processor.update(dt));\n        return this;\n    }\n}\n\nexport default EntityManager;\n"],"names":["clone","obj","copy","Date","setTime","getTime","Array","i","len","length","Object","attr","hasOwnProperty","listener","thingToCheck","emit","toString","call","entities","components","assemblages","entityComponentData","processors","uid","this","componentIds","entityId","initialState","getUid","addComponentsToEntity","includes","push","id","comp","splice","indexOf","component","forEach","_this","addComponent","name","keys","self","_this2","Error","newCompState","state","property","defineProperty","enumerable","get","set","val","__id","componentId","newState","updateComponentDataForEntity","sendEventToProcessors","_this3","sendUpdateEvent","compState","getComponentDataForEntity","key","assemblage","a","_this4","assemblageId","createEntity","undefined","processor","_this5","eventName","on","entity","_this6","dt","update"],"mappings":"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"}